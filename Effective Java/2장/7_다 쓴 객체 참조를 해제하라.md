# 아이템 7: 다 쓴 객체 참조를 해제하라

메모리 누수(memory leak)는 겉으로는 별다른 오류 없이 애플리케이션의 성능을 점진적으로 떨어뜨리다가 결국 시스템을 죽게 만드는 조용한 살인자다. **가비지 컬렉션 언어에서도 메모리 관리에 더 이상 신경 쓰지 않아도 되는 것이 아니다.**

## 문제 상황: 메모리 누수가 일어나는 Stack 클래스

다음은 메모리 누수가 일어나는 위험한 코드다:

```java
// 메모리 누수가 일어나는 위험한 코드!
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }
    
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

**문제점:** 이 코드에서는 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않는다. 프로그램에서 그 객체들을 더 이상 사용하지 않더라도 말이다.

**원인:** 스택이 그 객체들의 다 쓴 참조(obsolete reference)를 여전히 가지고 있기 때문이다.

## 해결 방법 1: null 처리

```java
// 제대로 구현한 pop 메서드
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제!
    return result;
}
```

**장점:**
- 다 쓴 참조를 즉시 null로 만들어 메모리 누수를 방지
- 실수로 참조를 사용하려 할 때 즉시 NullPointerException으로 오류 발견 가능

**주의사항:** 객체 참조를 null 처리하는 일은 **예외적인 경우**여야 한다. 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효한 범위(scope) 밖으로 밀어내는 것이다.

## 메모리 누수 주의 상황 3가지

### 1. 자기 메모리를 직접 관리하는 클래스

```java
// Stack 클래스처럼 자체적으로 메모리를 관리
public class CustomList {
    private Object[] elements;
    // 직접 메모리를 관리하므로 null 처리 필수
}
```

**해결책:** 해당 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리한다.

### 2. 캐시

```java
// 메모리 누수 위험이 있는 캐시
Map<Object, Object> cache = new HashMap<>();

// 해결책: WeakHashMap 사용
Map<Object, Object> cache = new WeakHashMap<>();
```

**해결책:**
- **WeakHashMap**을 사용해 캐시를 만들자
- 엔트리가 살아 있는 캐시가 필요한 시간을 정확히 알기 어렵다면 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식 사용
- **ScheduledThreadPoolExecutor** 같은 백그라운드 스레드 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행

WeakHashMap 간단 정리
-	HashMap: 키와 값 모두 강한 참조 → GC가 제거하지 않음
-	WeakHashMap: 키를 약한 참조로 저장 → 외부에서 키를 참조하지 않으면 GC가 자동 제거
- - 참조 대상이 필드/전역 변수라면 null로 처리를 해줘야 하고, 
  - 지역 변수라면 스코프 종료 시 자동으로 해제되므로 보통은 신경 안써도 된다.
-	주로 캐시나 임시 데이터 저장에 활용

### 3. 리스너(listener)와 콜백(callback)

```java
public interface EventListener {
    void onEvent(Event event);
}

public class EventManager {
    private final List<EventListener> listeners = new ArrayList<>();
    
    public void addListener(EventListener listener) {
        listeners.add(listener); // 해제하지 않으면 메모리 누수!
    }
    
    // 해결: 약한 참조로 저장
    private final List<WeakReference<EventListener>> listeners = new ArrayList<>();
}
```

**문제점:** 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 콜백은 계속 쌓여간다.

**해결책:** 콜백을 약한 참조(weak reference)로 저장하면 가비지 컬렉터가 즉시 수거해간다.

## 실제 사용 예시

### AutoCloseable 활용

```java
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();
    
    // 청소가 필요한 자원. 절대 Room을 참조해서는 안 된다!
    private static class State implements Runnable {
        int numJunkPiles; // 방(Room) 안의 쓰레기 수
        
        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        }
        
        // close 메서드나 cleaner가 호출한다.
        @Override public void run() {
            System.out.println("방 청소");
            numJunkPiles = 0;
        }
    }
    
    // 방의 상태. cleanable과 공유한다.
    private final State state;
    
    // cleanable 객체. 수거 대상이 되면 방을 청소한다.
    private final Cleaner.Cleanable cleanable;
    
    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    }
    
    @Override public void close() {
        cleanable.clean();
    }
}
```

### try-with-resources 사용

```java
public class Adult {
    public static void main(String[] args) {
        try (Room myRoom = new Room(7)) {
            System.out.println("안녕~");
        }
    }
}
```

## 핵심 정리

**메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다.** 이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. **그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.**

**언제 null 처리를 해야 하는가:**
1. **자기 메모리를 직접 관리하는 클래스**라면 프로그래머는 항시 메모리 누수에 주의해야 한다
2. **캐시 역시 메모리 누수를 일으키는 주범이다**
3. **리스너나 콜백**을 등록만 하고 해지하지 않는다면 메모리가 누적된다

**해결 방법:**
- 해당 클래스의 원소를 다 사용한 즉시 **null 처리**
- **WeakHashMap**, **약한 참조**, **Cleaner** 활용
- **try-with-resources** 사용으로 자동 정리