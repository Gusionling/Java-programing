# finalizer는 기본적으로 피해라
오동작, 낮은 성능, 이식성 문제의 원이이 되기도 한다. finalizer는 나름의 쓰임새가 몇 가지 있긴 하지만 기본적으로 '쓰지 말아야 한다.' 
**cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.** 

- finalizer와 cleaner는 즉시 수행된다는 보장이 없다. 
    -  finalizer나 cleaner를 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달려있다. 이는 가비지 컬렉터 구현마다 천차만별이다. 
    - 프로그램 생애 주기와 상관없는, 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다. 
- finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다. 
- 심각한 성능 문제도 있다.
- finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. 

# 그럼 대체 어케 해야됨? 
파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서는
- AutoCloseable을 구현해주고, 
- 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다.

각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋다. 

# 왜 씀?
- 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할이다.
- 네이티브 피어와 연결된 객체에서 유용하다.
    - native peer는 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. (네이티브 피어는 자바 객체가 아니기 때문에 가비지 컬렉터는 그 존재를 알 수 없다.)

